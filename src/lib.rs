/*!
Utilities to read and write binary messages in the PSAS rocket framework.
*/
extern crate byteorder;

use std::collections::HashMap;
use std::io::prelude::*;
use std::io::BufReader;
use std::io::BufWriter;
use std::io::Cursor;
use std::fs::File;
use std::path::Path;
use std::str;


// This module is entirely generated by the code generator based on defined message types.
pub mod messages;


/// Statistics about a set of telemetry messages
pub struct Stats {
    /// Number of `SEQN` (sequence number) encountered
    pub n_seqn: u64,

    /// The value of the first `SEQN` (sequence number) encountered
    pub first_seqn: u32,

    /// The value of the last `SEQN` (sequence number) encountered
    pub last_seqn: u32,

    /// Total number or bytes successfully read including unknown messages
    pub n_bytes: u64,

    /// Total number of messages encountered
    pub n_messages: u64,

    /// A map of the number of messages encountered, keyed by their four character code
    pub message_counts: HashMap<[u8;4], u64>,
}


/// Return a collection of statistics about a log file
pub fn get_stats(filename: String) -> Stats {

    // Read our file
    let fh = File::open(&filename).unwrap();
    let mut reader = BufReader::new(fh);

    // Initialize our stats to zero 
    let mut stats = Stats {
        n_seqn: 0,
        first_seqn: 0,
        last_seqn: 0,
        n_bytes: 0,
        n_messages: 0,
        message_counts: HashMap::new(),
    };

    // Flag to set after we find our first `SEQN` header
    let mut first_seqn = true;

    // Scan the file
    loop {

        let header = match messages::read_header(&mut reader) {
            Ok(header) => header,
            Err(err) => {
                eprintln!("Warning! \n{:?}", err);
                break;
            },
        };

        // We read a header message, which is always this many bytes
        stats.n_bytes += messages::SIZE_OF_HEADER as u64;

        // Try and copy the message size number of bytes into a buffer
        let mut body_buf = vec![0u8; header.size];
        match reader.read_exact(&mut body_buf) {
            Ok(()) => (),
            Err(err) => {
                eprintln!("Warning! \n{:?}", err);
                break;
            },
        };

        // Note the amount of bytes read
        stats.n_bytes += header.size as u64;

        // Match on the kind of message
        match &header.fourcc {
            b"SEQN" => {
                let seqn = messages::read_seqn_body(&body_buf);
                stats.n_seqn += 1;
                if first_seqn {
                    stats.first_seqn = seqn;
                    first_seqn = false;
                }
                stats.last_seqn = seqn;
            },
            _ => {
                stats.n_messages += 1;
                let n = stats.message_counts.entry(header.fourcc).or_insert(0);
                *n += 1;
            },
        };
    }

    stats
}


/// Given a logfile and a message type (four character code), write a CSV file
pub fn serialize_message_to_csv<I>(input_filename: &Path, fourcc_to_match: &[u8; 4], writer: &mut BufWriter<I>) where I: Write {
    // Read our file
    let fh = File::open(&input_filename).unwrap();
    let mut reader = BufReader::new(fh);

    let mut current_seqn = 0;

    loop {
        let header = match messages::read_header(&mut reader) {
            Ok(header) => header,
            Err(_) => break,
        };
        let mut body_buf = vec![0u8; header.size];
        match reader.read_exact(&mut body_buf) {
            Ok(()) => (),
            Err(_) => break,
        };

        // Keep track of the sequence number
        if &header.fourcc == b"SEQN" {
            current_seqn = messages::read_seqn_body(&body_buf);
        }

        if header.fourcc == *fourcc_to_match {
            // We match all in read_all, but because we're already filtering
            // we'll only get back the data we want
            match messages::to_csv(header.fourcc, body_buf) {
                Some(line) => write!(writer, "{},{},{}\n", current_seqn, header.timestamp, line).unwrap(),
                None => {},
            };
        }
    }
}


/// Parse file and only return certain sequence numbers. Writes into a buffer
pub fn trunc_sequence<I>(input_filename: &Path, seqn_i: i64, seqn_f: i64, keeplist: Vec<&str>, output_buffer: &mut BufWriter<I>) where I: Write {

    // Read our file
    let fh = File::open(input_filename).unwrap();
    let mut reader = BufReader::new(fh);

    let mut write = false;

    loop {
        let mut raw_header = [0; messages::SIZE_OF_HEADER];
        match reader.read_exact(&mut raw_header) {
            Ok(()) => (),
            Err(err) => {
                eprintln!("Warning! \n {:?}", err);
                break;
            },
        }
        let header = messages::read_header(&mut BufReader::new(Cursor::new(&raw_header))).unwrap();
        let mut body_buf = vec![0u8; header.size];
        match reader.read_exact(&mut body_buf) {
            Ok(()) => (),
            Err(err) => {
                eprintln!("Warning! \n {:?}", err);
                break;
            },
        };

        // Match on the kind of message
        match &header.fourcc {
            b"SEQN" => {
                let seqn = messages::read_seqn_body(&body_buf) as i64;

                // Valid ending SEQN
                if seqn_f > 0 {
                    // In the write range
                    if seqn >= seqn_i && seqn <= seqn_f {
                        write = true;
                        output_buffer.write(&raw_header).unwrap();
                        output_buffer.write(body_buf.as_slice()).unwrap();
                    }
                    else { write = false; }
                }
                else {
                    // In the write range as long as we're higher than the begin value
                    if seqn >= seqn_i {
                        write = true;
                        output_buffer.write(&raw_header).unwrap();
                        output_buffer.write(body_buf.as_slice()).unwrap();
                    }
                    else { write = false; }
                }
            }
            _ => {
                if write {
                    if keeplist.len() > 0 {
                        let fourcc = str::from_utf8(&header.fourcc).unwrap();
                        for mesg in &keeplist {
                            if &fourcc == mesg {
                                output_buffer.write(&raw_header).unwrap();
                                output_buffer.write(body_buf.as_slice()).unwrap();
                            }
                        }
                    }
                    else {
                        output_buffer.write(&raw_header).unwrap();
                        output_buffer.write(body_buf.as_slice()).unwrap();
                    }
                }
            },
        };
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use byteorder::{ReadBytesExt, BigEndian};
    use std::io::BufReader;
    use std::mem::size_of;

    #[test]
    fn get_file_stats_from_l12_short() {
        let stats = get_stats("testdata/launch-12_short.log".to_owned());
        assert_eq!(stats.n_seqn, 191);
        assert_eq!(stats.first_seqn, 0);
        assert_eq!(stats.last_seqn, 190);
        assert_eq!(stats.n_bytes, 249997);
        assert_eq!(stats.n_messages, 8755);

        // What's in our dict of message counts
        for (fourcc, n) in &stats.message_counts {
            match fourcc {
                b"FCFH" => assert_eq!(*n,   16),
                b"RNHH" => assert_eq!(*n,    9),
                b"VERS" => assert_eq!(*n,    1),
                b"SEQE" => assert_eq!(*n,    3),
                b"RNHP" => assert_eq!(*n, 8726),
                _ => {
                    // We should have found all the possible messages, so we don't want to get here!
                    eprintln!("{}", String::from_utf8_lossy(fourcc));
                    assert!(false);  // Fail!
                },
            }
        }
    }

    #[test]
    fn make_csv_of_one_message_type_inmem_from_l12_short() {

        let mem: Vec<u8> = Vec::new();
        let mut write_buffer = BufWriter::new(mem);
        let input_path = Path::new("testdata/launch-12_short.log");

        serialize_message_to_csv(input_path, b"RNHP", &mut write_buffer);

        // This is our "file" in memory
        let mem = write_buffer.into_inner().unwrap();
        let file_lines = String::from_utf8_lossy(&mem);

        let mut linecount = 0;
        for _ in file_lines.split("\n") {
            linecount += 1;
        }
        assert_eq!(linecount, 8727);
    }

    #[test]
    fn write_a_message_body() {
        // Test data. In MKS units
        let adis = messages::adis::ADIS {
            vcc: 5.0,
            acc_x: 9.999,
            acc_y: 0.0,
            acc_z: 0.0,
            gyro_x: 1.0,
            gyro_y: -100.0,
            gyro_z: 345.5,
            magn_x: 25e-6,
            magn_y: 0.1e-6,
            magn_z: -10e-6,
            temp: 24.0,
            aux_adc: 2.2345,
        };

        // Write data into binary form
        let mut buffer = vec![];
        adis.write_raw_bytes(&mut buffer);

        // Read it back out
        let mut cursor = Cursor::new(&*buffer);
        let rebuilt = messages::adis::ADIS_raw {
            vcc: cursor.read_u16::<BigEndian>().unwrap(),
            gyro_x: cursor.read_i16::<BigEndian>().unwrap(),
            gyro_y: cursor.read_i16::<BigEndian>().unwrap(),
            gyro_z: cursor.read_i16::<BigEndian>().unwrap(),
            acc_x: cursor.read_i16::<BigEndian>().unwrap(),
            acc_y: cursor.read_i16::<BigEndian>().unwrap(),
            acc_z: cursor.read_i16::<BigEndian>().unwrap(),
            magn_x: cursor.read_i16::<BigEndian>().unwrap(),
            magn_y: cursor.read_i16::<BigEndian>().unwrap(),
            magn_z: cursor.read_i16::<BigEndian>().unwrap(),
            temp: cursor.read_i16::<BigEndian>().unwrap(),
            aux_adc: cursor.read_i16::<BigEndian>().unwrap(),
        };
        assert_eq!(rebuilt.vcc, 2067);
        assert_eq!(rebuilt.gyro_x, 20);
        assert_eq!(rebuilt.gyro_y, -2000);
        assert_eq!(rebuilt.gyro_z, 6910);
        assert_eq!(rebuilt.acc_x, 3002);
        assert_eq!(rebuilt.acc_y, 0);
        assert_eq!(rebuilt.acc_z, 0);
        assert_eq!(rebuilt.magn_x, 500);
        assert_eq!(rebuilt.magn_y, 2);
        assert_eq!(rebuilt.magn_z, -200);
        assert_eq!(rebuilt.temp, 171);
        assert_eq!(rebuilt.aux_adc, 1801);
    }


    #[test]
    fn write_a_message_header() {
        // Write data into binary form
        let mut buffer: Vec<u8> = Vec::new();
        let header = messages::Header {
            fourcc: *b"MESG",
            timestamp: 123,
            size: 10,
        };
        header.write(&mut buffer);

        // Look for ASCII fourcc
        assert_eq!(buffer[0], 77);  // "M"
        assert_eq!(buffer[1], 69);  // "E"
        assert_eq!(buffer[2], 83);  // "S"
        assert_eq!(buffer[3], 71);  // "G"

        // Read back in round trip
        let mut rdr = BufReader::new(&*buffer);
        let header = messages::read_header(&mut rdr).unwrap();
        assert_eq!(&header.fourcc, b"MESG");
        assert_eq!(header.timestamp, 123);
        assert_eq!(header.size, 10);
    }


    #[test]
    fn write_a_message() {
        // Test data. In MKS units
        let adis = messages::adis::ADIS {
            vcc: 5.0,
            acc_x: 9.999,
            acc_y: 0.0,
            acc_z: 0.0,
            gyro_x: 1.0,
            gyro_y: -100.0,
            gyro_z: 345.5,
            magn_x: 25e-6,
            magn_y: 0.1e-6,
            magn_z: -10e-6,
            temp: 24.0,
            aux_adc: 2.2345,
        };

        // Write (time = 0)
        let mut buffer = vec![];
        adis.write_message(&mut buffer, 0);

        // Look for ASCII fourcc
        assert_eq!(buffer[0], 65);  // "A"
        assert_eq!(buffer[1], 68);  // "D"
        assert_eq!(buffer[2], 73);  // "I"
        assert_eq!(buffer[3], 83);  // "S"

        // Read back in round trip
        let mut rdr = BufReader::new(&*buffer);
        let new_header = messages::read_header(&mut rdr).unwrap();
        assert_eq!(&new_header.fourcc, b"ADIS");
        assert_eq!(new_header.timestamp, 0);
        assert_eq!(new_header.size, size_of::<messages::adis::ADIS_raw>());

        let mut body_buf = vec![0u8; new_header.size];
        rdr.read_exact(&mut body_buf).unwrap();
        let rebuilt = messages::adis::read_raw(body_buf);
        assert_eq!(rebuilt.vcc, 2067);
        assert_eq!(rebuilt.gyro_x, 20);
        assert_eq!(rebuilt.gyro_y, -2000);
        assert_eq!(rebuilt.gyro_z, 6910);
        assert_eq!(rebuilt.acc_x, 3002);
        assert_eq!(rebuilt.acc_y, 0);
        assert_eq!(rebuilt.acc_z, 0);
        assert_eq!(rebuilt.magn_x, 500);
        assert_eq!(rebuilt.magn_y, 2);
        assert_eq!(rebuilt.magn_z, -200);
        assert_eq!(rebuilt.temp, 171);
        assert_eq!(rebuilt.aux_adc, 1801);

    }
}
